<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on chux0519</title><link>https://chux0519.github.io/posts/</link><description>Recent content in Posts on chux0519</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 22 Oct 2019 22:40:20 +0800</lastBuildDate><atom:link href="https://chux0519.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode Rust Bfs</title><link>https://chux0519.github.io/posts/leetcode-rust-bfs/</link><pubDate>Tue, 22 Oct 2019 22:40:20 +0800</pubDate><guid>https://chux0519.github.io/posts/leetcode-rust-bfs/</guid><description>算法系列 - BFS BFS 指广度优先搜索，是一种遍历树、图的方法。
BFS 通常会和队列相关，但不完全等于队列。以下是我在 leetcode 刷题后的整理。
层级相关 首先存在一类题目，通常会和树的层级遍历相关，这类型的题目是存在固定解题模式的。
首先定义节点
#[derive(Debug, PartialEq, Eq)] pub struct TreeNode { pub val: i32, pub left: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, pub right: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, } 然后模板通常为以下，或稍微有些变化，但主体框架都是一致的。
// root: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt; let mut q = VecDeque::new(); q.push_back(root); while !q.is_empty() { // 每一层 let mut level = Vec::new(); for _ in 0..q.len() { // 在遍历过程中，q 会被更新，进入下一层 let front = q.pop_front().unwrap(); if let Some(f) = front { let f = f.</description></item></channel></rss>